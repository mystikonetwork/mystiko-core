import unsafeRandomBytes from 'randombytes';
import { Scalar } from 'ffjavascript';
import createBlakeHash from 'blake-hash';
import { pedersenHash, eddsa, babyJub, mimcsponge } from 'circomlib';
import cryptojs from 'crypto-js';
import aes from 'crypto-js/aes';
import hmacSHA512 from 'crypto-js/hmac-sha512';
import eccrypto from 'eccrypto';
import MerkleTree from 'fixed-merkle-tree';
import { groth16, wtns } from 'snarkjs';
import bs58 from 'bs58';
import BN from 'bn.js';
import { toHex, toString, check, toHexNoPrefix, readJsonFile } from '../utils.js';
import logger from '../logger.js';

/**
 * @module module:mystiko/protocol/default
 * @desc default implementation of Mystiko protocol.
 */
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.FIELD_SIZE
 * @type {external:BN}
 * @desc infinite field size constant in zkSnark runtime.
 */
export const FIELD_SIZE = new BN(
  '21888242871839275222246405745257275088548364400416034343698204186575808495617',
);
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.VERIFY_PK_SIZE
 * @type {number}
 * @desc the number bytes of public key for zkp verification.
 */
export const VERIFY_PK_SIZE = 32;
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.VERIFY_SK_SIZE
 * @type {number}
 * @desc the number bytes of secret key for zkp verification.
 */
export const VERIFY_SK_SIZE = 32;
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.RANDOM_SK_SIZE
 * @type {number}
 * @desc the number bytes of random secret when generating commitment.
 */
export const RANDOM_SK_SIZE = 16;
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.ENCRYPT_SK_SIZE
 * @type {number}
 * @desc the number bytes of secret key for asymmetric encryption.
 */
export const ENCRYPT_SK_SIZE = 32;
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.ENCRYPT_PK_SIZE
 * @type {number}
 * @desc the number bytes of public key for asymmetric encryption.
 */
export const ENCRYPT_PK_SIZE = 33;
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.HASH_SIZE
 * @type {number}
 * @desc the number bytes of hash function output.
 */
export const HASH_SIZE = 32;
/**
 * @memberOf module:mystiko/protocol/default
 * @name module:mystiko/protocol/default.MERKLE_TREE_LEVELS
 * @type {number}
 * @desc the number of levels of the merkle tree stored on chain.
 */
export const MERKLE_TREE_LEVELS = 20;

const ECIES_IV_LENGTH = 16;
const ECIES_EPHEM_PK_LENGTH = 65;
const ECIES_MAC_LENGTH = 32;
const ECIES_META_LENGTH = ECIES_IV_LENGTH + ECIES_EPHEM_PK_LENGTH + ECIES_MAC_LENGTH;

/**
 * @function module:mystiko/protocol/default.randomBigInt
 * @desc generate random big number which could fit into the given number of bytes.
 * @param {number} [numBytes=32] number of bytes this generated big number must be fit into.
 * @returns {external:BN} a {@link external:BN} instance, which should be less than
 * {@link module:mystiko/protocol/default.FIELD_SIZE}
 */
export function randomBigInt(numBytes = 32) {
  let bigInt = new BN(toHexNoPrefix(unsafeRandomBytes(numBytes)), 16);
  if (bigInt.gte(FIELD_SIZE)) {
    bigInt = bigInt.mod(FIELD_SIZE);
  }
  return bigInt;
}

/**
 * @function module:mystiko/protocol/default.randomBytes
 * @desc generate random bytes with the given number of bytes.
 * @param {number} [numBytes=32] number of bytes this generated big number must be fit into.
 * @returns {Buffer} the generated bytes as Buffer.
 */
export function randomBytes(numBytes = 32) {
  return bigIntToBuff(randomBigInt(numBytes), numBytes);
}

/**
 * @function module:mystiko/protocol/default.secretKeyForVerification
 * @desc get the secret key for verification from the raw secret key.
 * @param {Buffer} rawSecretKey raw secret key bytes.
 * @returns {Buffer} the secret key as Buffer.
 */
export function secretKeyForVerification(rawSecretKey) {
  check(rawSecretKey instanceof Buffer, 'unsupported rawSecretKey type ' + typeof rawSecretKey);
  check(rawSecretKey.length === VERIFY_SK_SIZE, 'rawSecretKey length does not equal to ' + VERIFY_SK_SIZE);
  const keyHash = createBlakeHash('blake512').update(rawSecretKey).digest().slice(0, VERIFY_SK_SIZE);
  const sBuffer = eddsa.pruneBuffer(keyHash);
  const skBigInt = Scalar.shr(buffToBigInt(sBuffer).toString(), 3);
  check(FIELD_SIZE.gt(new BN(skBigInt.toString())), 'skBigInt should be less than FIELD_SIZE');
  const sk = bigIntToBuff(new BN(skBigInt.toString()), VERIFY_SK_SIZE);
  check(
    sk.length === VERIFY_SK_SIZE,
    'converted secret key length ' + sk.length + ' not equal to ' + FIELD_SIZE,
  );
  return sk;
}

/**
 * @function module:mystiko/protocol/default.publicKeyForVerification
 * @desc get the public key for verification from the raw secret key.
 * @param {Buffer} rawSecretKey raw secret key bytes.
 * @returns {Buffer} the public key as Buffer.
 */
export function publicKeyForVerification(rawSecretKey) {
  check(rawSecretKey instanceof Buffer, 'unsupported rawSecretKey type ' + typeof rawSecretKey);
  check(rawSecretKey.length === VERIFY_SK_SIZE, 'rawSecretKey length does not equal to ' + VERIFY_SK_SIZE);
  const unpackedPoints = eddsa.prv2pub(rawSecretKey);
  check(unpackedPoints[0] < FIELD_SIZE, 'first point should be less than FIELD_SIZE');
  const pk = bigIntToBuff(new BN(unpackedPoints[0].toString()), VERIFY_PK_SIZE);
  check(
    pk.length === VERIFY_PK_SIZE,
    'converted public key length ' + pk.length + ' not equal to ' + FIELD_SIZE,
  );
  return pk;
}

/**
 * @function module:mystiko/protocol/default.secretKeyForEncryption
 * @desc get the secret key for asymmetric encryption from the raw secret key.
 * @param {Buffer} rawSecretKey raw secret key bytes.
 * @returns {Buffer} the secret key as Buffer.
 */
export function secretKeyForEncryption(rawSecretKey) {
  check(rawSecretKey instanceof Buffer, 'unsupported rawSecretKey type ' + typeof rawSecretKey);
  check(rawSecretKey.length === ENCRYPT_SK_SIZE, 'rawSecretKey length does not equal to ' + ENCRYPT_SK_SIZE);
  return rawSecretKey;
}

/**
 * @function module:mystiko/protocol/default.publicKeyForEncryption
 * @desc get the public key for asymmetric encryption from the raw secret key.
 * @param {Buffer} rawSecretKey raw secret key bytes.
 * @returns {Buffer} the public key as Buffer.
 */
export function publicKeyForEncryption(rawSecretKey) {
  check(rawSecretKey instanceof Buffer, 'unsupported rawSecretKey type ' + typeof rawSecretKey);
  check(rawSecretKey.length === ENCRYPT_SK_SIZE, 'rawSecretKey length does not equal to ' + ENCRYPT_SK_SIZE);
  const publicKey = eccrypto.getPublicCompressed(rawSecretKey);
  check(
    publicKey.length === ENCRYPT_PK_SIZE,
    'generate public key length does not equal to ' + ENCRYPT_PK_SIZE,
  );
  return publicKey;
}

/**
 * @function module:mystiko/protocol/default.fullPublicKey
 * @desc get full single public key by combing public key for zkp verification
 * and public key for asymmetric encryption.
 * @param {Buffer} pkVerify public key for zkp verification.
 * @param {Buffer} pkEnc public key for asymmetric encryption.
 * @returns {Buffer} a single Buffer as a full public key.
 */
export function fullPublicKey(pkVerify, pkEnc) {
  check(pkVerify instanceof Buffer, 'unsupported pkVerify type ' + typeof pkVerify);
  check(pkVerify.length === VERIFY_PK_SIZE, 'pkVerify length does not equal to ' + VERIFY_PK_SIZE);
  check(pkEnc instanceof Buffer, 'unsupported pkEnc type ' + typeof pkEnc);
  check(pkEnc.length === ENCRYPT_PK_SIZE, 'pkEnc length does not equal to ' + ENCRYPT_PK_SIZE);
  return Buffer.concat([pkVerify, pkEnc]);
}

/**
 * @function module:mystiko/protocol/default.fullSecretKey
 * @desc get full single secret key by combing secret key for zkp verification
 * and secret key for asymmetric encryption.
 * @param {Buffer} skVerify secret key for zkp verification.
 * @param {Buffer} skEnc secret key for asymmetric encryption.
 * @returns {Buffer} a single Buffer as a full secret key.
 */
export function fullSecretKey(skVerify, skEnc) {
  check(skVerify instanceof Buffer, 'unsupported skVerify type ' + typeof skVerify);
  check(skVerify.length === VERIFY_SK_SIZE, 'skVerify length does not equal to ' + VERIFY_SK_SIZE);
  check(skEnc instanceof Buffer, 'unsupported skEnc type ' + typeof skEnc);
  check(skEnc.length === ENCRYPT_SK_SIZE, 'skEnc length does not equal to ' + ENCRYPT_SK_SIZE);
  return Buffer.concat([skVerify, skEnc]);
}

/**
 * @function module:mystiko/protocol/default.separatedPublicKeys
 * @desc get separated public keys from single full key, it returns public key for zkp verification and
 * public key for asymmetric encryption.
 * @param {Buffer} fullPublicKey a single full public key instance.
 * @returns {{pkEnc: Buffer, pkVerify: Buffer}} the separated public keys.
 * @throws {Error} if the input full public key has incorrect length.
 */
export function separatedPublicKeys(fullPublicKey) {
  check(fullPublicKey instanceof Buffer, 'unsupported fullPublicKey type ' + typeof fullPublicKey);
  const expectedSize = VERIFY_PK_SIZE + ENCRYPT_PK_SIZE;
  check(fullPublicKey.length === expectedSize, 'fullPublicKey length does not equal to ' + expectedSize);
  return { pkVerify: fullPublicKey.slice(0, VERIFY_PK_SIZE), pkEnc: fullPublicKey.slice(VERIFY_PK_SIZE) };
}

/**
 * @function module:mystiko/protocol/default.separatedSecretKeys
 * @desc get separated secrets keys from single full key, it returns secret key for zkp verification and
 * secret key for asymmetric encryption.
 * @param {Buffer} fullSecretKey a single full secret key instance.
 * @returns {{skVerify: Buffer, skEnc: Buffer}} the separated secret keys.
 * @throws {Error} if the input full secret key has incorrect length.
 */
export function separatedSecretKeys(fullSecretKey) {
  check(fullSecretKey instanceof Buffer, 'unsupported fullSecretKey type ' + typeof fullSecretKey);
  const expectedSize = VERIFY_SK_SIZE + ENCRYPT_SK_SIZE;
  check(fullSecretKey.length === expectedSize, 'fullSecretKey length does not equal to ' + expectedSize);
  return { skVerify: fullSecretKey.slice(0, VERIFY_SK_SIZE), skEnc: fullSecretKey.slice(VERIFY_SK_SIZE) };
}

/**
 * @function module:mystiko/protocol/default.shieldedAddress
 * @desc convert a pair of public keys to Base58 encoded shielded address.
 * @param {Buffer} pkVerify public key for zkp verification.
 * @param {Buffer} pkEnc public key for asymmetric encryption.
 * @returns {string} Base58 encoded shielded address.
 */
export function shieldedAddress(pkVerify, pkEnc) {
  return bs58.encode(fullPublicKey(pkVerify, pkEnc));
}

/**
 * @function module:mystiko/protocol/default.isShieldedAddress
 * @desc check whether a given address string is shielded address.
 * @param {string} address the address string
 * @returns {boolean} true if it is valid, otherwise it returns false.
 */
export function isShieldedAddress(address) {
  if (typeof address === 'string') {
    try {
      const decoded = bs58.decode(address);
      if (decoded.length === VERIFY_PK_SIZE + ENCRYPT_PK_SIZE) {
        return true;
      }
    } catch {
      return false;
    }
  }
  return false;
}

/**
 * @function module:mystiko/protocol/default.publicKeysFromShieldedAddress
 * @desc get separated public keys from shielded address.
 * @param {string} address the address string.
 * @returns {{pkEnc: Buffer, pkVerify: Buffer}} the separated public keys.
 * @throws {Error} if the given address string is not a valid shielded address.
 */
export function publicKeysFromShieldedAddress(address) {
  check(isShieldedAddress(address), address + ' is a invalid address format');
  return separatedPublicKeys(bs58.decode(address));
}

/**
 * @function module:mystiko/protocol/default.encryptAsymmetric
 * @desc do asymmetric encryption by ECIES encryption scheme.
 * @param {Buffer} publicKey public key for this encryption.
 * @param {Buffer} plainData plain data to be encrypted.
 * @returns {Promise<Buffer>} promise of an encrypted data buffer.
 */
export async function encryptAsymmetric(publicKey, plainData) {
  check(publicKey instanceof Buffer, 'unsupported publicKey type ' + typeof publicKey);
  check(plainData instanceof Buffer, 'unsupported plainData type ' + typeof plainData);
  return await eccrypto.encrypt(publicKey, plainData).then((r) => {
    return Buffer.concat([r.iv, r.ephemPublicKey, r.mac, r.ciphertext]);
  });
}

/**
 * @function module:mystiko/protocol/default.decryptAsymmetric
 * @desc do asymmetric decryption with ECIES encryption scheme.
 * @param {Buffer} secretKey secret key for this decryption.
 * @param {Buffer} cipherData encrypted data to be decrypted.
 * @returns {Promise<Buffer>} promise of a decrypted data buffer.
 */
export async function decryptAsymmetric(secretKey, cipherData) {
  check(secretKey instanceof Buffer, 'unsupported secretKey type ' + typeof secretKey);
  check(cipherData instanceof Buffer, 'unsupported cipherData type ' + typeof cipherData);
  check(cipherData.length > ECIES_META_LENGTH, 'incorrected cipherData length');

  return await eccrypto.decrypt(secretKey, {
    iv: cipherData.slice(0, ECIES_IV_LENGTH),
    ephemPublicKey: cipherData.slice(ECIES_IV_LENGTH, ECIES_IV_LENGTH + ECIES_EPHEM_PK_LENGTH),
    mac: cipherData.slice(ECIES_IV_LENGTH + ECIES_EPHEM_PK_LENGTH, ECIES_META_LENGTH),
    ciphertext: cipherData.slice(ECIES_META_LENGTH),
  });
}

/**
 * @function module:mystiko/protocol/default.encryptSymmetric
 * @desc do symmetric encryption with AES encryption scheme.
 * @param {string} password the password for AES encryption.
 * @param {string} plainText plain text data to be encrypted.
 * @returns {string} encrypted data string.
 */
export function encryptSymmetric(password, plainText) {
  check(typeof password === 'string', 'unsupported password type ' + typeof password);
  check(typeof plainText === 'string', 'unsupported plainText type ' + typeof plainText);
  return aes.encrypt(plainText, password).toString();
}

/**
 * @function module:mystiko/protocol/default.decryptSymmetric
 * @desc do symmetric decryption with AES encryption scheme.
 * @param {string} password the password for AES encryption.
 * @param {string} cipherText encrypted data to be decrypted.
 * @returns {string} decrypted data string.
 */
export function decryptSymmetric(password, cipherText) {
  check(typeof password === 'string', 'unsupported password type ' + typeof password);
  check(typeof cipherText === 'string', 'unsupported cipherText type ' + typeof plainText);
  return aes.decrypt(cipherText, password).toString(cryptojs.enc.Utf8);
}

/**
 * @function module:mystiko/protocol/default.hash
 * @desc calculate the hash of given data with Pedersen Hash algorithm.
 * @param {Buffer} data input data to calculate the hash.
 * @returns {external:BN} a big number as the hash.
 */
export function hash(data) {
  check(data instanceof Buffer, 'unsupported data type ' + typeof data);
  const packedPoints = pedersenHash.hash(data);
  const unpackedPoints = babyJub.unpackPoint(packedPoints);
  check(unpackedPoints[0] < FIELD_SIZE, 'first point should be less than FIELD_SIZE');
  return new BN(unpackedPoints[0].toString());
}

/**
 * @function module:mystiko/protocol/default.hash2
 * @desc calculate the hash of two big numbers with MiMC Sponge hash algorithm.
 * @param {external:BN} left left item to be hashed.
 * @param {external:BN} right right item to be hashed.
 * @returns {external:BN} a big number as the hash.
 */
export function hash2(left, right) {
  check(left instanceof BN, 'unsupported left instance, should be BN');
  check(right instanceof BN, 'unsupported right instance, should be BN');
  const result = mimcsponge.multiHash([left.toString(), right.toString()], 0, 1);
  return new BN(result.toString());
}

/**
 * @function module:mystiko/protocol/default.checkSum
 * @desc calculate the checksum of given data with the salt, by using HMAC+SHA512 algorithm.
 * @param {string} data data to calculate the checksum.
 * @param {string} [salt='mystiko'] a salt for improve security.
 * @returns {string} the checksum of given data.
 */
export function checkSum(data, salt = 'mystiko') {
  check(typeof data === 'string', 'unsupported data type ' + typeof data);
  check(typeof salt === 'string', 'unsupported salt type ' + typeof salt);
  return hmacSHA512(data, salt).toString();
}

/**
 * @function module:mystiko/protocol/default.buffToBigInt
 * @desc convert a Buffer into big number with little endianness.
 * @param {Buffer} buff instance to be converted.
 * @returns {external:BN} the converted big number.
 */
export function buffToBigInt(buff) {
  check(buff instanceof Buffer, 'unsupported buff type ' + typeof buff);
  let res = new BN(0);
  for (let i = 0; i < buff.length; i++) {
    const byteNumber = new BN(buff[i]);
    res = res.add(byteNumber.shln(8 * i));
  }
  return res;
}

/**
 * @function module:mystiko/protocol/default.bigIntToBuff
 * @desc convert a big number into Buffer with little endianness.
 * @param {external:BN} bigInt the big number to be converted.
 * @param {number} [numBytes=32] expected number of bytes to fit this big number.
 * @returns {Buffer} the converted buffer with the length same as the given numBytes.
 * @throws {Error} if the big number cannot fit into the given number of bytes.
 */
export function bigIntToBuff(bigInt, numBytes = 32) {
  check(bigInt instanceof BN, 'bigInt should be instance of BN');
  let res = bigInt;
  let index = 0;
  const buff = new Uint8Array(numBytes);
  while (res.gt(new BN(0)) && index < numBytes) {
    buff[index] = Number(res.and(new BN(255)).toString());
    index = index + 1;
    res = res.shrn(8);
  }
  if (!res.isZero()) {
    throw new Error('Number does not fit in this length');
  }
  return Buffer.from(buff);
}

/**
 * @function module:mystiko/protocol/default.commitment
 * @desc calculate the commitment for the deposit transaction.
 * @param {Buffer} pkVerify public key for zkp verification.
 * @param {Buffer} pkEnc public key for asymmetric encryption.
 * @param {external:BN} amount asset amount to be deposited.
 * @param {Buffer} [randomP] random secret P. If not given, this function will generate a random one.
 * @param {Buffer} [randomR] random secret R. If not given, this function will generate a random one.
 * @param {external:BN} [randomS] random secret S. If not given, this function will generate a random one.
 * @returns {Promise<{privateNote: Buffer, randomS: external:BN, commitmentHash: external:BN, k: external:BN}>}
 * the encrypted private note, random secret S, intermediate hash k and the commitment hash.
 */
export async function commitment(
  pkVerify,
  pkEnc,
  amount,
  randomP = undefined,
  randomR = undefined,
  randomS = undefined,
) {
  check(pkVerify instanceof Buffer, 'unsupported pkVerify type ' + typeof pkVerify);
  check(pkEnc instanceof Buffer, 'unsupported pkEnc type ' + typeof pkEnc);
  check(amount instanceof BN, 'amount should be instance of BN');
  check(!randomS || randomP instanceof Buffer, 'unsupported randomP type ' + typeof randomP);
  check(!randomR || randomR instanceof Buffer, 'unsupported randomR type ' + typeof randomR);
  check(!randomS || randomS instanceof BN, 'randomS should be instance of BN');
  randomP = randomP ? randomP : randomBytes(RANDOM_SK_SIZE);
  randomR = randomR ? randomR : randomBytes(RANDOM_SK_SIZE);
  randomS = randomS ? randomS : randomBigInt(RANDOM_SK_SIZE);
  const k = hash(Buffer.concat([pkVerify, randomP, randomR]));
  const commitmentHash = hash2(hash2(k, amount), randomS);
  const privateNote = await encryptAsymmetric(
    pkEnc,
    Buffer.concat([randomP, randomR, bigIntToBuff(randomS, RANDOM_SK_SIZE)]),
  );
  logger.debug(
    'commitment generation is done:' +
      `commitmentHash='${toString(commitmentHash)}', ` +
      `randomS='${toString(randomS)}', ` +
      `privateNote='${toHex(privateNote)}'`,
  );
  return { commitmentHash, k, randomS, privateNote };
}

/**
 * @function module:mystiko/protocol/default.commitmentWithShieldedAddress
 * @desc calculate the commitment for the deposit transaction with the recipient shielded address.
 * @param {string} shieldedAddress the shielded address for this deposit goes to.
 * @param {external:BN} amount asset amount to be deposited.
 * @param {Buffer} [randomP] random secret P. If not given, this function will generate a random one.
 * @param {Buffer} [randomR] random secret R. If not given, this function will generate a random one.
 * @param {external:BN} [randomS] random secret S. If not given, this function will generate a random one.
 * @returns {Promise<{privateNote: Buffer, randomS: external:BN, commitmentHash: external:BN, k: external:BN}>}
 * the encrypted private note, random secret S, intermediate hash k and the commitment hash.
 */
export async function commitmentWithShieldedAddress(
  shieldedAddress,
  amount,
  randomP = undefined,
  randomR = undefined,
  randomS = undefined,
) {
  check(typeof shieldedAddress === 'string', 'shieldedAddress should be string');
  const { pkVerify, pkEnc } = publicKeysFromShieldedAddress(shieldedAddress);
  return await commitment(pkVerify, pkEnc, amount, randomP, randomR, randomS);
}

/**
 * @function module:mystiko/protocol/default.serialNumber
 * @desc calculate serial number for withdrawal transaction.
 * @param {Buffer} skVerify secret key for zkp verification.
 * @param {Buffer} randomP random secret P.
 * @returns {external:BN} the calculated serial number.
 */
export function serialNumber(skVerify, randomP) {
  check(skVerify instanceof Buffer, 'unsupported skVerify type ' + typeof skVerify);
  check(randomP instanceof Buffer, 'unsupported skVerify type ' + typeof randomP);
  return hash(Buffer.concat([randomP, skVerify]));
}

/**
 * @function module:mystiko/protocol/default.zkProve
 * @desc generate zkSnark proofs with given public and private inputs.
 * This function is using Groth16 zkSnark scheme for generating proofs.
 * @param {Buffer} pkVerify public key for zkp verification.
 * @param {Buffer} skVerify secret key for zkp verification.
 * @param {Buffer} pkEnc public key for asymmetric encryption.
 * @param {Buffer} skEnc secret key for asymmetric encryption.
 * @param {external:BN} amount the amount of the deposited asset.
 * @param {external:BN} commitmentHash the commitment hash in the deposit transaction.
 * @param {Buffer} privateNote the encrypted on-chain private note, which include the value of
 * random secret P, random secret R, random secret S.
 * @param {external:BN[]} treeLeaves all existing commitment in same merkle tree, we treat it as
 * merkle tree leaves.
 * @param {number} treeIndex current commitment's index as a merkle tree leaf.
 * @param {string} wasmFile the path of zkSnark circuit file in WASM format.
 * @param {string} zkeyFile the path of zkSnark proving keys.
 * @returns {Promise<{publicSignals: string[], proof: {pi_a: string[], pi_b: string[][], pi_c: string[]}}>}
 * a calculated zkSnark proof.
 */
export async function zkProve(
  pkVerify,
  skVerify,
  pkEnc,
  skEnc,
  amount,
  commitmentHash,
  privateNote,
  treeLeaves,
  treeIndex,
  wasmFile,
  zkeyFile,
) {
  check(pkVerify instanceof Buffer, 'unsupported pkVerify type ' + typeof pkVerify);
  check(skVerify instanceof Buffer, 'unsupported skVerify type ' + typeof skVerify);
  check(pkEnc instanceof Buffer, 'unsupported pkEnc type ' + typeof pkEnc);
  check(skEnc instanceof Buffer, 'unsupported skEnc type ' + typeof skEnc);
  check(amount instanceof BN, 'amount should be instance of BN');
  check(commitmentHash instanceof BN, 'commitmentHash should be instance of BN');
  check(privateNote instanceof Buffer, 'unsupported privateNote type ' + typeof privateNote);
  check(treeLeaves instanceof Array, 'unsupported treeLeaves type ' + typeof treeLeaves);
  check(typeof treeIndex === 'number', 'unsupported treeIndex type ' + typeof treeIndex);
  check(typeof wasmFile === 'string', 'unsupported wasmFile type ' + typeof wasmFile);
  check(typeof zkeyFile === 'string', 'unsupported zkeyFile type ' + typeof zkeyFile);
  logger.debug('start generating zkSnark proofs...');
  const decryptedNote = await decryptAsymmetric(skEnc, privateNote);
  check(decryptedNote.length === RANDOM_SK_SIZE * 3, 'decrypted note length is incorrect');
  const randomP = decryptedNote.slice(0, RANDOM_SK_SIZE);
  const randomR = decryptedNote.slice(RANDOM_SK_SIZE, RANDOM_SK_SIZE * 2);
  const randomS = decryptedNote.slice(RANDOM_SK_SIZE * 2);
  const computedCommitmentHash = await commitment(
    pkVerify,
    pkEnc,
    amount,
    randomP,
    randomR,
    buffToBigInt(randomS),
  );
  check(
    toHex(commitmentHash) === toHex(computedCommitmentHash.commitmentHash),
    'given commitmentHash does not match with other parameters',
  );
  const sn = serialNumber(skVerify, randomP);
  const tree = new MerkleTree(MERKLE_TREE_LEVELS, treeLeaves);
  const { pathElements, pathIndices } = tree.path(treeIndex);
  const inputs = {
    // public inputs
    rootHash: tree.root(),
    serialNumber: sn.toString(),
    amount: amount.toString(),
    // private inputs
    pathElements,
    pathIndices,
    publicKey: buffToBigInt(pkVerify).toString(),
    secretKey: buffToBigInt(skVerify).toString(),
    randomP: buffToBigInt(randomP).toString(),
    randomR: buffToBigInt(randomR).toString(),
    randomS: buffToBigInt(randomS).toString(),
    commitment: commitmentHash.toString(),
  };
  logger.debug(
    'calculating witness with public inputs:' +
      `rootHash='${toString(tree.root())}', ` +
      `serialNumber='${toString(serialNumber)}', ` +
      `amount="${toString(amount)}"'`,
  );
  const wtnsOptions = { type: 'mem' };
  await wtns.calculate(inputs, wasmFile, wtnsOptions);
  logger.debug('witness calculation is done, start proving...');
  const proofs = await groth16.prove(zkeyFile, wtnsOptions);
  logger.debug('zkSnark proof is generated successfully');
  return proofs;
}

/**
 * @function module:mystiko/protocol/default.zkVerify
 * @desc verify the generated zkSnark proof locally with the given verification key.
 * @param {{pi_a: string[], pi_b: string[][], pi_c: string[]}} proof generated zkSnark proofs.
 * @param {string[]} publicSignals public inputs.
 * @param {string} verifyKeyFile path of zkSnark verification key file.
 * @returns {Promise<boolean>} a promise of true if it verifies successfully, otherwise it returns a promise of false.
 */
export async function zkVerify(proof, publicSignals, verifyKeyFile) {
  const vkey = await readJsonFile(verifyKeyFile);
  logger.debug('start verifying generated proofs...');
  const result = await groth16.verify(vkey, publicSignals, proof);
  logger.debug(`proof verification is done, result=${result}`);
  return result;
}
